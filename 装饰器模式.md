# 1、ES7 装饰器模式Decoretor
装饰器是 ES7 的内容，装饰模式可以不修改类原有的接口功能条件下，使得更加'优雅'，就好比给手机加一个手机壳，可以防摔，又不影响手机原有的通话、充电等功能。

## 2、decorater的使用
以英雄为例，英雄的初始能力值都比较低，只是‘装备’了很多东西才能变得更加NB，但是不管怎么样，他的初始值都是那么多，假如我们的示例场景是这样的:
- 首先创建一个英雄，他的生命值为50，魔法值为50，攻击力为10
- 然后我们让其佩戴短剑，这样他的攻击力增加10，变成20
- 让他穿上狂徒铠甲，生命值变为120
- 最后让他拥有'跳跃'能力

### 2.1 装配短剑
首先创建Hero类:
```javascript
class Hero {
  constructor(hp = 50, mp = 50, atk = 10) {
    this.init(hp, mp, atk)
  }

  init(hp, mp, atk) {
    this.hp = hp
    this.mp = mp
    this.atk = atk
  }

  toString() {
    return `血量${this.hp},魔力${this.mp},攻击力${this.atk}`
  }
}

var ez = new Hero()
console.log(`当前状态 --> ${ez}`)   // 当前状态 --> 血量50,魔力50,攻击力10
```

创建`decorateSword`方法，为英雄佩戴短剑，需要装饰在方法 init 上面:
```javascript
const decorateSword = (target, key, descriptor) => {
  const method = descriptor.value
  let moreAtk = 10
  descriptor.value = (...args) => {
    args[2] += moreAtk
    return method.apply(target, args)
  }
  return descriptor
}

class Hero {
  constructor(hp = 50, mp = 50, atk = 10) {
    this.init(hp, mp, atk)
  }

  @decorateSword
  init(hp, mp, atk) {
    this.hp = hp
    this.mp = mp
    this.atk = atk
  }

  toString() {
    return `血量${this.hp},魔力${this.mp},攻击力${this.atk}`
  }
}

var ez = new Hero()
console.log(`当前状态 --> ${ez}`)     // 当前状态 --> 血量50,魔力50,攻击力20
```

可以看到攻击力成功增加了10，变成了20，表示我们的装饰器起作用了，但是为什么`decorateSword`的参数是这三个，并且为什么要返回`descriptor`呢?

- Decorators的本质就是用了 `Object.defineProperty`，这三个参数是和其中的一致的，不可以更改
- 所以装饰器中的target为一个Hero的实例属性，key为`init`, descriptor为一个描述符对象(与Object.defineProperty中的类似)

### 2.2 穿上狂徒
在上面的例子中，成功给英雄装备了短剑，下面我们给英雄装备狂徒，使用`decoratePlate`
我们只需要拷贝`decorateSword`方法，作出一些修改就可以了，最后的方法及使用方法如下:
```javascript
const decoratePlate = (target, key, descriptor) => {
  const method = descriptor.value
  let moreMp = 70
  descriptor.value = (...args) => {
    args[1] += moreMp
    return method.apply(target, args)
  }
  return descriptor
}

// ...
@decorateArmour
@decorateLight
init(hp, mp, atk) {
  this.hp = hp
  this.mp = mp
  this.atk = atk
}

// ...
console.log(`当前状态 --> ${ez}`)     // 当前状态 --> 血量120,魔力50,攻击力20
```

可见装饰器的优势，就是可以对某个方法进行叠加使用，对原类的入侵非常的小，只是增加了一行而已，便于修改以及复用

### 2.3 增加'跳跃'能力
装饰模式具有两种形态: `纯粹的装饰模式` 和 `半透明的装饰模式`

上面两个例子都是`纯粹的装饰模式`，它并不增加对原有类的接口，接下来的例子就属于`半透明的装饰模式`，增加一个'跳跃'方法，如下:
```javascript
const addJump = (canJump) => {
  return (target) => {
    target.canJump = canJump
    let extra = canJump ? '(技能加成: 跳跃能力)' : ''
    let method = target.prototype.toString
    target.prototype.toString = (...args) => {
      return method.apply(target.prototype, args) + extra
    }
    return target
  }
}
```

我们可以使用这个方法去装饰类，使用如下:
```javascript
@addJump(true)
class Hero {
  constructor(hp = 50, mp = 50, atk = 10) {
    this.init(hp, mp, atk)
  }

  @decorateSword
  @decoratePlate
  init(hp, mp, atk) {
    this.hp = hp
    this.mp = mp
    this.atk = atk
  }

  toString() {
    return `血量${this.hp},魔力${this.mp},攻击力${this.atk}`
  }
}

// ...
console.log(`当前状态 ===> ${ez}`)  // 当前状态 --> 血量120,魔力50,攻击力20,(技能加成: 跳跃能力)
```

可见，作用在方法上的 `decorator` 接收的第一个参数(`target`)是类的 prototype，作用在类上的第一个参数就是类的本身

## 3.经典实现(Logger)
使用`decorator` 可以很方便的实现一个日志收集的功能:
```javascript
const log = (type) => {
  return (target, key, descriptor) => {
    const method = descriptor.value         // 保证原有方法的纯净性
    descriptor.value = (...args) => {
      console.info(`(${type}) 正在执行: ${key}(${args}) = ?`)
      let ret
      try {
        ret = method.apply(target, args)
        console.log(`(${type}) 成功: ${key}(${args}) = ?`)
      } catch(error) {
        console.error(`(${type}) 失败: ${key}(${args}) = ?`)
      }
      return ret
    }
  }
}

class Hero {
  @log('hero 创建')
  new(){
    return '创建完毕'
  }

  @log('hero 攻击')
  attack(){
    return '击倒敌人'
  }

  @log('hero 出错')
  error(){
    throw '糟了'
  }
}

var ez = new Hero()
ez.new()            // (hero 创建)正在执行: new() = ?     (hero 创建)正在执行: new() => 创建完毕
ez.attack()
ez.error()
```

当我们需要创建更多英雄的时候，手动创建就比较麻烦，此时，我们可以使用工厂模式: **定义一个创建对象的接口，让其子类自己决定实例化那一个工厂类，使其创建过程延迟到子类中进行**

参考: [ES7 Decorator 装饰者模式](http://taobaofed.org/blog/2015/11/16/es7-decorator/)